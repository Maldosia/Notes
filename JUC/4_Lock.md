# JUC

- java.util.concurrent
- java.util.concurrent.atomic
- java.util.concurrent.lock

# 1. 相关概念

## 1.1 乐观锁

### 1.1.1 概念

```shell
#一种乐观思想，即认为读多写少，遇到并发的可能性低，每次拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新的时候会判断一下在此期间别人有没有更改这个数据，采取在写时先读出当前版本号，然后加锁操作(比较上一次的版本号，如果一样则更新，如果不一样，则重复读-比较-写)。
#java中的乐观锁基本上是通过CAS操作实现的，CAS是一种原子操作(比较当前值与传入值是否一样，一样则更新)。JUC中都是通过Unsafe类的compareAndSwap方法操作。
#存在ABA问题，即线程1(A->B)执行成功，线程2(A->B)阻塞，线程3(B->A)成功，线程2(A->B)成功。可以通过AtomicStampedReference解决。
```

## 1.2 悲观锁

### 1.2.1 概念

```shell
#一种悲观思想，即认为写多读少，遇到并发的可能性高，每次拿数据的时候都认为别人会修改，所以在每次读写数据的时候都会上锁。
#java中的悲观锁就是Synchronized，AQS框架下的锁则是先尝试CAS乐观锁去获取锁，获取不到，才会转为悲观锁，如ReentrantLock。
```

## 1.3 自旋锁

### 1.3.1 概念

```shell
#如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等(自旋)，等持有锁的线程释放锁之后即可立即获取锁，这样就避免了用户线程和内核的切换消耗。
#自旋是需要消耗CPU的，这段时间CPU在做无用功，所以需要设置一个自旋的最大等待时间。
#如果持有锁的线程执行时间超过了其它线程的最大自旋时间，那么导致其它线程进入阻塞状态。
```

### 1.3.2 优点

尽可能的减少线程的阻塞，这对于**锁竞争不激烈且占用锁时间非常短的代码**来说性能能大幅度的提升，因为自旋的消耗小于线程从阻塞挂起再唤醒的操作消耗。

### 1.3.3 缺点

对于**锁竞争激烈，或者持有锁线程执行时间长**，那么其它线程在获取锁之前都是在做无用功，自旋消耗大于线程阻塞挂起操作的消耗，且其它需要CPU的线程又得不到CPU，造成资源浪费。

### 1.3.4 时间阈值

jdk1.5是写死的，jdk1.6引入了适应性自旋锁，意味着时间不是固定的，**由前一次在同一个锁上的自旋时间以及锁的拥有者状态来决定**。

## 1.4 公平锁与非公平锁

### 1.4.1 公平锁

加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得

### 1.4.2 非公平锁

加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待

1. 非公平锁性能比公平锁高5~10倍，因为公平锁需要在多核的情况下维护一个队列。
2. Synchronized是非公平锁，ReentrantLock默认的lock()方法采用的是非公平锁。

## 1.5 可重入锁

### 1.5.1 概念

```shell
#递归锁，同一线程外层函数获得锁之后，内层递归函数任然有获取该锁的代码，但不受影响。ReentrantLock和Synchronized都是可重入锁。
```

## 2. 对象头之markword

![](images\对象头之Markword.png)

# 3. Synchronized

## 3.1 概念

```shell
#可以把任意一个非NULL的对象当成锁，属于独占式的悲观锁，同时属于可重入锁。
#jdk1.6是默认开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking来禁用偏向锁。
```

## 3.2 作用范围

- 作用在方法时，锁对象是实例(this)；
- 作用在静态方法时，锁对象是Class实例；
- 作用在某个实例对象时，锁对象是该实例对象。

## 3.3 锁的升级(synchronized)

### 3.3.1 升级过程

```shell
#无锁-->偏向锁-->轻量级锁-->重量级锁
无锁：程序不会有锁的竞争，不需要加锁
#无锁-->偏向锁
当对象被当作同步锁并有一个线程A抢到了锁时，锁标志位不变，是否偏向锁设置为1，前23bit设置线程A的ID，此时表示进入偏向锁状态。
#偏向锁-->轻量级锁
当线程B试图获取这个锁时，JVM发现同步锁处于偏向状态，但是markword中线程ID记录的不是B，则B会先用CAS操作试图获取获取锁(置换线程ID)。一定会失败？失败则撤销偏向锁并且设置为轻量级锁。
#轻量级锁-->重量级锁
线程B自旋一定次数任未获取到锁，设置markword为重量级锁，线程阻塞。线程A同步代码执行完后，CAS替换markword失败(因为线程B修改了)，释放锁并唤醒等待的线程，然后markword设置为0|10。
```

### 3.3.2 撤销偏向锁流程

```shell
#待到全局安全点，暂停线程A(原持有偏向锁的线程)
#暂停线程A，判断线程A是否存活。
#否，则markword设置无锁状态；是，则设置为轻量级锁，唤醒线程。
```

## 3.4 核心组件

```shell
#1.Contention List：竞争队列，所有请求锁的线程首先放在这里
#2.Entry List：Contention List中有资格成为候选资源的线程移动到这里
#3.Wait Set：调用了wait方法被阻塞的线程放到这里
#4.OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被称为OnDeck
#5.Owner：当前已经获得锁的线程
#6.!Owner：当前释放锁的线程
```

## 3.5 流程

1. JVM每次从ContentList尾部取出一个用于锁竞争候选者(OnDeck)，但是并发情况下，ContentList会被大量的并发线程CAS访问，为了降低对尾部元素的竞争，JVM会将一部分线程移动到Entry List。
2. Owner线程会在unlock时，将ContentList中的部分线程迁移到EntryList中，并指定EntryList中的某个线程为OnDeck线程(一般是先进去的那个)。
3. Owner线程并不会直接把锁传递给OnDeck线程，而是把锁竞争的权利交给OnDeck，OnDeck也需要重新竞争锁。称为竞争切换。
4. OnDeck线程获取到锁资源后会变成Owner线程，而没有获取到锁的任然停留在EntryList中。如果Owner线程被wait方法阻塞，则转移到WaitSet中，知道某个时刻被notify或者notifyAll唤醒重新进入EntryList中。

## 3.6 非公平性

```shell
#1.在线程进入ContentList前，等待的线程会尝试自旋获取锁，如果获取不到进入ContentList，这对于已经进入队列的线程来说是不公平的。
#2.自旋获取锁的线程还可能直接抢占OnDeck线程的锁。
```



