# JUC

- java.util.concurrent
- java.util.concurrent.atomic
- java.util.concurrent.lock

# 1. 相关概念

## 1.1 乐观锁

### 1.1.1 概念

```shell
#1.一种乐观思想，即认为读多写少，遇到并发的可能性低，每次拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新的时候会判断一下在此期间别人有没有更改这个数据，采取在写时先读出当前版本号，然后加锁操作(比较上一次的版本号，如果一样则更新，如果不一样，则重复读-比较-写)。
#2.java中的乐观锁基本上是通过CAS操作实现的，CAS是一种原子操作(比较当前值与传入值是否一样，一样则更新)。JUC中都是通过Unsafe类的compareAndSwap方法操作。
#3.存在ABA问题，即线程1(A->B)执行成功，线程2(A->B)阻塞，线程3(B->A)成功，线程2(A->B)成功。可以通过AtomicStampedReference解决。
```

## 1.2 悲观锁

### 1.2.1 概念

```shell
#1.一种悲观思想，即认为写多读少，遇到并发的可能性高，每次拿数据的时候都认为别人会修改，所以在每次读写数据的时候都会上锁。
#2.java中的悲观锁就是Synchronized，AQS框架下的锁则是先尝试CAS乐观锁去获取锁，获取不到，才会转为悲观锁，如ReentrantLock。
```

## 1.3 自旋锁

### 1.3.1 概念

```shell
#1.如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等(自旋)，等持有锁的线程释放锁之后即可立即获取锁，这样就避免了用户线程和内核的切换消耗。
#2.自旋是需要消耗CPU的，这段时间CPU在做无用功，所以需要设置一个自旋的最大等待时间。
#3.如果持有锁的线程执行时间超过了其它线程的最大自旋时间，那么导致其它线程进入阻塞状态。
```

### 1.3.2 优点

尽可能的减少线程的阻塞，这对于**锁竞争不激烈且占用锁时间非常短的代码**来说性能能大幅度的提升，因为自旋的消耗小于线程从阻塞挂起再唤醒的操作消耗。

### 1.3.3 缺点

对于**锁竞争激烈，或者持有锁线程执行时间长**，那么其它线程在获取锁之前都是在做无用功，自旋消耗大于线程阻塞挂起操作的消耗，且其它需要CPU的线程又得不到CPU，造成资源浪费。

### 1.3.4 时间阈值

jdk1.5是写死的，jdk1.6引入了适应性自旋锁，意味着时间不是固定的，**由前一次在同一个锁上的自旋时间以及锁的拥有者状态来决定**。

## 1.4 公平锁与非公平锁

### 1.4.1 公平锁

加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得

### 1.4.2 非公平锁

加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待

1. 非公平锁性能比公平锁高5~10倍，因为公平锁需要在多核的情况下维护一个队列。
2. Synchronized是非公平锁，ReentrantLock默认的lock()方法采用的是非公平锁。

## 1.5 可重入锁

### 1.5.1 概念

```shell
#递归锁，同一线程外层函数获得锁之后，内层递归函数任然有获取该锁的代码，但不受影响。ReentrantLock和Synchronized都是可重入锁。
```

## 2. 对象头之markword

![](images\对象头之Markword.png)

