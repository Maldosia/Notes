#### 一、持久化机制

##### 1、RDB(快照)持久化

- Redis调用fork()，产生一个子进程；
- 子进程将数据写到一个临时的RDB文件；
- 当子进程写完新的RDB文件后，把旧的RDB文件替换调

###### 文件配置：

```shell
#RDB文件名，默认dump.rdb
dbfilename dump.rdb
#文件存放的目录，AOF文件同样放在此目录下。默认为当前工作目录。
dir ./
```

###### 保存点

```shell
#例如下面的配置表示每60s，如果数据发生了1000次以上的变动，redis就会自动保存快照文件。
save 60 1000
#可以设置多个保存点，默认三个
save 900 1
save 300 10
save 60 10000
#禁用RDB功能，注释所有的save配置，或者添加
save ""
```

###### 手动生成快照

```shell
#BGSAVE
BGSAVE命令使用后台的方式保存RDB文件，调用此命令后，立刻返回OK。Redis会产生一个子进程进行快照写入硬盘。父进程继续处理命令请求。
#SAVE
SAVE命令会使用同步的方式生成RDB快照文件，这意味着在这个过程中会阻塞所有其它的客户端请求。不建议在生产环境使用这个命令。
```

###### 重点

```shell
1.如果设置了save命令，那么从Redis最近一次创建快照之后开始算起。当条件被满足时，自动发出BGSAVE命令。
2.当Redis收到shutdown命令或者接收到标准TERM信号时，会执行一次SAVE命令，阻塞所有客户端，并且执行后关闭Redis服务。
```

##### 2、AOF(追加)持久化

```shell
#启动AOF,默认no
appendonly yes
```

###### 文件配置

```shell
#AOF文件名，默认appendonly.aof
appendfilename appendonly.aof
#文件存放的目录，AOF文件同样放在此目录下。默认为当前工作目录。
dir ./
```

###### 刷新频率

```shell
#每当有新命令追加到AOF的时候调用fsync，速度最慢，最安全
appendfsync always
#每秒fsync一次，速度快，安全性不错(最多丢失1秒的数据)
appendfsync everysec
#从不fsync，交由系统处理。这个方式最快，但安全性一般
appendfsync no
```

###### 流程

```
命令写入 --> 追加到aof_buf --> 同步到aof磁盘
如果在追加时，磁盘空间满，断电等情况导致日志不完整，Redis提供了redis-check-aof工具进行日志修复。
```

#### 二、订阅与发布

###### 订阅频道

```shell
#服务器中维护着pubsub_channels字典，存储所有的频道和订阅关系。Key为频道的名称，Value为订阅频道的客户端的链表。
```

###### 订阅模式

```shell
#服务器中维护着pubsub_pattern链表，链表的parttern属性记录了被订阅的模式，而client属性记录了订阅模式的客户端。
```

```shell
#订阅频道
subscribe channel1 [channel2 ...]
#取消订阅频道
unsubscribe channel1 [channel2 ...]
#订阅模式
psubscribe parttern1 [parttern2 ...]
#取消订阅模式
punsubscribe parttern1 [parttern2 ...]
#发布消息
publish channel message
#查看已有频道
pubsub channels [parttern] #列出当前的活跃频道，如果给定parttern参数，则会返回与parttern模式相匹配的频道。
pubsub numsub [channel1 ...] #返回给定频道的订阅者数量，订阅模式的客户端不算在内。
pubsub numpat #返回订阅模式的数量
```

#### 三、过期策略

```shell
#Redis会给每个设置了过期时间的key放入到一个独立的字典里，以后会定期遍历这个字典来删除到期的key。
#每100ms扫描一次，过期扫描不会遍历字典里的所有key，而是随机抽取key，检查是否过期，如果过期就删除。
```

###### 定时删除

含义：在设置key的过期时间时，创建一个定时器，让定时器在过期时间来临时，删除该key。

优点：  保证内存尽快被释放。

缺点：  

- 若过期key很多，删除这些key会占用很多的CPU时间；
- 定时器的创建耗时，若为每个有过期时间的key创建一个定时器，性能影响严重。

###### 惰性删除

含义：key过期的时候不删除，每次获取key的时候检查是否过期，若过期，则删除并返回null。

优点：只删除当前key，对CPU时间的占用较少。

缺点：若大量的key在超出过期时间后，很久一段时间都没有被获取过，那么可能发生内存泄漏。

###### 定期删除

含义：每隔一段时间执行一次过期key删除操作，频率可以配置。

优点：

- 通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用-----处理“定时删除”的缺点；
- 定期删除过期key-----处理“惰性删除”的缺点。

缺点：

- 在内存友好方面，不如定时删除；
- 在CPU友好方面，不如惰性删除。

难点：

- 合理设置删除操作的执行时长
- 合理设置删除操作的执行频率

###### Redis采用的过期策略

惰性删除+定期删除

- 惰性删除流程
  - 在进行get或setnx等操作时，先检查key是否过期，
  - 若过期，删除key，然后执行相应操作；
  - 若没过期，直接执行相应操作
- 定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）
  - 遍历每个数据库（就是redis.conf中配置的"database"数量，默认为16）
    - 检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）
      - 如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历
      - 随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key
      - 判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。

###### RDB对过期key的处理

- 从内存数据库持久化数据到RDB文件：
  - 持久化key之前，会检查是否过期，过期的key不进入RDB文件。
- 从RDB文件恢复数据到内存数据库：
  - 数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）。

###### AOF对过期key的处理

- 从内存数据库持久化数据到AOF文件：
  - 当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）；
  - 当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）。
- AOF重写：
  - 会先判断key是否过期，已过期的key不会重写到AOF文件 。

#### 四、内存淘汰机制

###### 最大内存参数

```shell
maxmemory <bytes>
```

###### 内存淘汰策略

```shell
volatile-lru     #从已设置过期时间的数据集中挑选最久未使用的数据
allkeys-lru      #从数据集中挑选最久未使用的数据
volatile-lfu     #从已设置过期时间的数据集中挑选使用频率最低的数据
allkeys-lfu      #从数据集中挑选使用频率最低的数据
volatile-random  #从已设置过期时间的数据集中随机挑选数据
allkeys-random   #从数据集中随机挑选数据
volatile-ttl     #从已设置过期时间的数据集中挑选将要过期的数据
noeviction       #no-eviction，止驱逐数据，默认策略。当内存不足以容纳新的数据时，写入操作会报错。
```

#### 五、缓存问题

###### 缓存雪崩问题

```shell
一、缓存因某种原因发生了宕机，那么海量查询直接请求到数据库。
#解决方案
1.使用缓存集群，保证缓存高可用
2.使用Hystrix等防雪崩工具，通过熔断、降级、限流手段来降低雪崩发生后的损失。
二、缓存同一时间大面积失效，所有的请求都落到数据库
#解决方案
1.缓存数据的过期时间设置随机，防止同一时间大量数据过期
2.给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存
3.缓存预热
4.互斥锁
```

###### 缓存击穿问题

```shell
热点数据集中失效，导致海量数据直接请求到数据库。
#解决方案
1.互斥锁，第一个请求在获取缓存时加锁，让其它请求阻塞等待。当第一个请求完成数据库操作并写入缓存后，释放锁。其它请求就可以直接访问缓存。互斥锁可以避免某一个热点数据失效导致数据库崩溃，而在实际业务中，往往存在一批热点数据同时失效，此时可以向缓存中存储这些数据时，将过期时间错开。
2.永远不过期，为每个key设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。
#比较
1.互斥锁，如果构建缓存过程出现问题或者时间较长，可能会存在死锁和线程池阻塞的风险。
2.永远不过期，会存在数据库不一致的情况，同时代码复杂度会增加。
```

###### 缓存穿透问题

```shell
业务系统访问不存在的数据(缓存没有，数据库也没有)。
#危害
大量请求直接落到数据库，数据库压力剧增，可能会导致系统崩溃。
#原因
1.恶意攻击，故意营造大量不存在的数据请求系统；
2.代码逻辑错误。
#解决方案
1.缓存空数据，将数据库查询结果为空的key也存储在缓存中，后续请求出现该key时，缓存直接放回null，无需请求数据库；
	问题1：空值做缓存，需要更多的内存空间。可以设置一个较短的过期时间，自动删除。
	问题2：有一段时间窗口的不一致。在该key未过期时，数据库添加了这个数据，那么导致数据库与缓存数据不一致。可以利用消息中间件或其           它方式清除该key。
2.BloomFilter，查询请求时，先在BloomFilter中查询该key是否存在。若不存在，则说明数据库也不存在，那么缓存直接返回null。
	问题：数据命中不高，适合数据实时性较低的场景，代码维护较为复杂。
```

缓存与数据库读写一致性