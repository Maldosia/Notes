# ThreadPoolExecutor

Class ThreadPoolExecutor --> AbstractExecutorService --> Interface ExecutorService --> Interface Executor 

#### 构造函数

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
```

1.corePoolSize 核心线程数 线程池里面保持的线程数量(即使线程是空闲的)。

2.maximumPoolSize 最大线程数 线程池里允许的最大线程数量。

3.keepAliveTime 当线程池里的线程超过了corePoolSize，多出的线程在销毁之前等待新任务到来的最长时间。

4.unit keepAliveTime的时间单位。

5.workQueue 用来存放那些调用execute方法提交的但未被执行的任务。

6.threadFactory 使用此工厂创建执行器需要的新线程。

7.handler 阻塞队列达到了容量最大值时，执行器调用此处理器执行任务拒绝策略。

#### 阻塞队列

| 方法类型 | 抛出异常  | 特殊值   | 阻塞   | 超时               |
| -------- | --------- | -------- | ------ | ------------------ |
| 插入     | add(e)    | offer(e) | put(e) | offer(e,time,unit) |
| 移除     | remove()  | poll()   | take() | poll(time,unit)    |
| 检查     | element() | peek()   | 不可用 | 不可用             |

- SynchronousQueue(直接提交队列) 没有容量，只允许有一个任务。如果用于执行任务的线程数量小于maximumPoolSize，则尝试创建新的线程。如果达到maximumPoolSize值，则执行拒绝策略。
- ArrayBlockingQueue(有界任务队列) 需要初始化容量。创建新的线程达到corePoolSize,将任务放入等待队列。若等待队列已满，继续创建新的线程，直到maximumPoolSize。若大于maximumPoolSize，则执行拒绝策略。这种情况下，线程的数量与队列数量相关。若队列容量较大或未达到超负载状态，线程数将一直维持在corePoolSize。反之队列任务满时，线程池会以maximumPoolSize为最大线程数上限。
- LinkedBlockingQueue (无界任务队列) 线程池中的最大线程数量就是corePoolSize,maximumPoolSize无效。若后续有新的任务加入，直接进入队列等待。

#### 线程池的优点

- 降低资源消耗 通过重复利用已创建的线程降低线程创建和销毁线程造成的消耗。
- 提高响应速度 当任务到达时，不需要等到线程创建就能立即执行。
- 提高线程的可管理性 线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性。使用线程池可以进行统一分配，调优和监控。

### 任务分类

```java
public class FutureTask implement RunnableFuture{
    public FutureTask(Callable callable){}
    public FutureTask(Runnable runnable,V result){}
}

public interface RunnableFuture extends Runnable,Future{
    void run();
}
```

#### ExecutorService

- submit() 可以接收Runnable和Callback，返回Future对象，通过future.get()可以获取任务返回值
- execute() 只能接口Runnable，无返回值
- shutdown() 停止接收新的任务，正在运行的和队列中的任务继续完成后才真正停止
- shutdownNow() 停止接收新的任务，忽略队列里等待的任务，尝试将正在执行的任务interrupt中断，返回未执行任务列表
- awaitTermination() 当前线程阻塞，返回结果true(shutdown请求后所有任务执行完毕)或false(已超时)

